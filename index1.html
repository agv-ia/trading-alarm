<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Trading Alarm</title>

<!-- Tailwind CDN -->
<script src="https://cdn.tailwindcss.com"></script>
<!-- Lightweight Charts -->
<script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.2/dist/lightweight-charts.standalone.production.js"></script>

<style>
  body {
    background-color: #0b0b0b;
    color: white;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    margin: 0; padding: 0; height: 100vh; overflow: hidden;
    display: flex; flex-direction: column;
  }
  #title {
    text-align: center;
    font-weight: 700;
    font-size: 1.8rem;
    padding: 1rem 0;
    border-bottom: 1px solid #333;
    background: #0a0a0a;
    user-select: none;
  }
  #main {
    display: flex;
    flex-grow: 1;
    height: calc(100vh - 3.5rem);
    overflow: hidden;
  }
  #trading-data {
    width: 20%;
    background: #121212;
    border-right: 1px solid #333;
    padding: 0.5rem 0.75rem;
    overflow-y: auto;
  }
  #trading-live {
    flex-grow: 1;
    background: #181818;
    padding: 0.5rem 0.75rem;
    display: flex;
    flex-direction: column;
  }
  #trading-conf {
    height: 12.5%;
    background: #121212;
    border-top: 1px solid #333;
    display: flex;
    align-items: center;
    padding-left: 1rem;
  }
  button.btn {
    background: #272727;
    border: none;
    color: white;
    padding: 0.5rem 1rem;
    margin-right: 0.75rem;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 600;
    user-select: none;
    transition: background-color 0.2s;
  }
  button.btn:hover {
    background: #3c3c3c;
  }
  /* Popup styling */
  #popup-container {
    position: fixed;
    top: 10vh;
    left: 50%;
    transform: translateX(-50%);
    background: #1a1a1a;
    border: 1px solid #444;
    box-shadow: 0 0 15px #000000cc;
    padding: 1rem 1.25rem;
    z-index: 1000;
    width: 320px;
    max-height: 75vh;
    overflow-y: auto;
    border-radius: 8px;
  }
  #popup-container h3 {
    margin-bottom: 0.75rem;
    font-weight: 700;
    font-size: 1.2rem;
    user-select: none;
  }
  #popup-container .close-btn {
    position: absolute;
    right: 1rem;
    top: 1rem;
    cursor: pointer;
    font-size: 1.3rem;
    user-select: none;
    color: #ccc;
  }
  #popup-container .close-btn:hover {
    color: white;
  }
  #crypto-list {
    list-style: none;
    padding-left: 0;
    max-height: 300px;
    overflow-y: auto;
    border: 1px solid #444;
    border-radius: 4px;
  }
  #crypto-list li {
    padding: 0.5rem 0.75rem;
    cursor: pointer;
    border-bottom: 1px solid #333;
    display: flex;
    justify-content: space-between;
    align-items: center;
    user-select: none;
  }
  #crypto-list li:hover {
    background: #333;
  }
  #crypto-list li.selected {
    background: #0084ff;
  }
  #alerts-options {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }
  input[type=number], input[type=text] {
    background: #222;
    border: 1px solid #555;
    padding: 0.4rem 0.6rem;
    color: white;
    width: 100%;
    border-radius: 4px;
    font-size: 1rem;
  }
  label {
    font-weight: 600;
    margin-bottom: 0.3rem;
    display: block;
  }
  .threshold-label {
    position: absolute;
    font-size: 0.75rem;
    font-weight: 600;
    color: #aaa;
    background: rgba(30,30,30,0.8);
    padding: 0 6px;
    border-radius: 3px;
    pointer-events: none;
    user-select: none;
  }
</style>
</head>
<body>

<div id="title">Trading Alarm</div>

<div id="main">

  <div id="trading-data">
    <h2 class="text-lg font-semibold mb-4">Trading Data</h2>
    <ul id="coin-list" class="space-y-1 text-sm"></ul>
  </div>

  <div id="trading-live">
    <div id="chart" style="flex-grow: 1; position: relative;"></div>
  </div>

</div>

<div id="trading-conf">
  <button class="btn" id="btn-crypto">Criptomonedas</button>
  <button class="btn" id="btn-thresholds">Umbrales</button>
  <button class="btn" id="btn-alerts">Alertas</button>
</div>

<div id="popup-container" style="display:none;"></div>

<script>
(() => {
  // Config defaults
  const DEFAULT_SYMBOL = 'BTCUSDT';
  const DEFAULT_THRESHOLDS = { min: -2, max: 2 };
  const LOCALSTORAGE_KEYS = {
    symbol: 'trading_alarm_symbol',
    thresholds: 'trading_alarm_thresholds',
    alertsRealTime: 'trading_alarm_alerts_realtime'
  };
  // Binance popular coins (USDT pairs)
  const popularCoins = [
    'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'ADAUSDT', 'SOLUSDT',
    'XRPUSDT', 'DOTUSDT', 'DOGEUSDT', 'AVAXUSDT', 'MATICUSDT',
    'LTCUSDT', 'SHIBUSDT', 'TRXUSDT', 'UNIUSDT', 'BCHUSDT',
    'LINKUSDT', 'ALGOUSDT', 'VETUSDT', 'ICPUSDT', 'FILUSDT'
  ];

  // State variables
  let selectedSymbol = localStorage.getItem(LOCALSTORAGE_KEYS.symbol) || DEFAULT_SYMBOL;
  let thresholds = JSON.parse(localStorage.getItem(LOCALSTORAGE_KEYS.thresholds)) || DEFAULT_THRESHOLDS;
  let alertsRealTimeEnabled = localStorage.getItem(LOCALSTORAGE_KEYS.alertsRealTime) === 'true' ? true : false;

  // Chart variables
  let chart = null;
  let candleSeries = null;
  let upperThresholdSeries = null;
  let lowerThresholdSeries = null;
  let upperThresholdLabel = null;
  let lowerThresholdLabel = null;

  // DOM Elements
  const coinListElem = document.getElementById('coin-list');
  const popupContainer = document.getElementById('popup-container');
  const btnCrypto = document.getElementById('btn-crypto');
  const btnThresholds = document.getElementById('btn-thresholds');
  const btnAlerts = document.getElementById('btn-alerts');
  const chartContainer = document.getElementById('chart');

  // Helper: Sleep for ms
  const sleep = ms => new Promise(res => setTimeout(res, ms));

  // Fetch with retry (3 attempts)
  async function fetchWithRetry(url, options = {}, retries = 3, delay = 1000) {
    for(let i = 0; i < retries; i++) {
      try {
        const resp = await fetch(url, options);
        if(!resp.ok) throw new Error(`HTTP ${resp.status}`);
        return resp.json();
      } catch(e) {
        if(i === retries - 1) throw e;
        await sleep(delay);
      }
    }
  }

  // Fetch price and 24h change info for all coins in popularCoins
  async function fetchCoinsInfo() {
    try {
      const url = 'https://api.binance.com/api/v3/ticker/24hr';
      const data = await fetchWithRetry(url);
      // Filter only popular coins
      const filtered = data.filter(c => popularCoins.includes(c.symbol));
      // Map to symbol info with price and priceChangePercent
      return filtered.map(c => ({
        symbol: c.symbol,
        lastPrice: parseFloat(c.lastPrice),
        priceChangePercent: parseFloat(c.priceChangePercent)
      }));
    } catch (e) {
      showError(`Error cargando datos de monedas: ${e.message}`);
      return [];
    }
  }

  // Initialize coin list in Trading Data section
  async function initCoinList() {
    const coins = await fetchCoinsInfo();
    coinListElem.innerHTML = '';
    coins.forEach(coin => {
      const li = document.createElement('li');
      li.textContent = `${coin.symbol}  `;
      const priceSpan = document.createElement('span');
      priceSpan.textContent = coin.lastPrice.toFixed(4);
      priceSpan.className = 'ml-auto mr-3';
      const changeSpan = document.createElement('span');
      changeSpan.textContent = (coin.priceChangePercent >= 0 ? '+' : '') + coin.priceChangePercent.toFixed(2) + '%';
      changeSpan.className = coin.priceChangePercent >= 0 ? 'text-green-500' : 'text-red-500';
      li.appendChild(priceSpan);
      li.appendChild(changeSpan);
      coinListElem.appendChild(li);
    });
  }

  // Initialize chart with LightweightCharts
  function initChart() {
    if(chart) {
      chart.remove();
      chart = null;
      candleSeries = null;
      upperThresholdSeries = null;
      lowerThresholdSeries = null;
      removeThresholdLabels();
    }
    chart = LightweightCharts.createChart(chartContainer, {
      width: chartContainer.clientWidth,
      height: chartContainer.clientHeight,
      layout: {
        backgroundColor: '#181818',
        textColor: '#d1d4dc',
      },
      grid: {
        vertLines: {
          color: '#2b2b2b',
        },
        horzLines: {
          color: '#2b2b2b',
        },
      },
      rightPriceScale: {
        borderColor: '#555',
      },
      timeScale: {
        borderColor: '#555',
        timeVisible: true,
        secondsVisible: false,
        rightOffset: 10,
        barSpacing: 10,
        fixLeftEdge: true,
        fixRightEdge: true,
      },
      crosshair: {
        mode: LightweightCharts.CrosshairMode.Normal,
      },
      localization: {
        locale: 'es-ES',
      },
      handleScroll: {
        mouseWheel: true,
        pressedMouseMove: true,
      },
      handleScale: {
        axisPressedMouseMove: true,
        mouseWheel: true,
        pinch: true,
      },
    });
    candleSeries = chart.addCandlestickSeries({
      upColor: '#26a69a',
      downColor: '#ef5350',
      borderDownColor: '#ef5350',
      borderUpColor: '#26a69a',
      wickDownColor: '#ef5350',
      wickUpColor: '#26a69a',
    });
    upperThresholdSeries = chart.addLineSeries({
      color: '#00ffff',
      lineWidth: 2,
      lineStyle: LightweightCharts.LineStyle.Dashed,
    });
    lowerThresholdSeries = chart.addLineSeries({
      color: '#ff6e6e',
      lineWidth: 2,
      lineStyle: LightweightCharts.LineStyle.Dashed,
    });

    window.addEventListener('resize', () => {
      chart.applyOptions({ width: chartContainer.clientWidth, height: chartContainer.clientHeight });
    });
  }

  // Fetch Klines from Binance API
  async function fetchKlines(symbol, interval = '1m', limit = 100) {
    try {
      const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
      const resp = await fetch(url);
      if(!resp.ok) throw new Error(`Binance API error: ${resp.status}`);
      const klines = await resp.json();
      return klines.map(k => ({
        time: k[0] / 1000,
        open: parseFloat(k[1]),
        high: parseFloat(k[2]),
        low: parseFloat(k[3]),
        close: parseFloat(k[4]),
        volume: parseFloat(k[5]),
      }));
    } catch(e) {
      throw e;
    }
  }

  // Draw thresholds lines on chart with labels
  function drawThresholds(basePrice) {
    if (!basePrice) return;
    const upPrice = +(basePrice * (1 + thresholds.max / 100)).toFixed(6);
    const lowPrice = +(basePrice * (1 + thresholds.min / 100)).toFixed(6);

    // Prepare lines: we draw horizontal lines across full range
    const timeRange = chart.timeScale().getVisibleRange();
    if (!timeRange) return;

    const start = timeRange.from;
    const end = timeRange.to;

    // Line points for upper threshold
    upperThresholdSeries.setData([
      { time: start, value: upPrice },
      { time: end, value: upPrice }
    ]);
    // Line points for lower threshold
    lowerThresholdSeries.setData([
      { time: start, value: lowPrice },
      { time: end, value: lowPrice }
    ]);

    addThresholdLabels(upPrice, lowPrice);
  }

  // Remove threshold labels if exist
  function removeThresholdLabels() {
    if (upperThresholdLabel) {
      upperThresholdLabel.remove();
      upperThresholdLabel = null;
    }
    if (lowerThresholdLabel) {
      lowerThresholdLabel.remove();
      lowerThresholdLabel = null;
    }
  }

  // Add threshold labels above/below lines
  function addThresholdLabels(upPrice, lowPrice) {
    removeThresholdLabels();

    // Create labels as divs positioned absolutely
    upperThresholdLabel = document.createElement('div');
    upperThresholdLabel.className = 'threshold-label';
    upperThresholdLabel.style.position = 'absolute';
    upperThresholdLabel.style.top = '5px';
    upperThresholdLabel.style.right = '10px';
    upperThresholdLabel.textContent = `Umbral Máximo: ${upPrice}`;

    lowerThresholdLabel = document.createElement('div');
    lowerThresholdLabel.className = 'threshold-label';
    lowerThresholdLabel.style.position = 'absolute';
    lowerThresholdLabel.style.bottom = '5px';
    lowerThresholdLabel.style.right = '10px';
    lowerThresholdLabel.textContent = `Umbral Mínimo: ${lowPrice}`;

    chartContainer.appendChild(upperThresholdLabel);
    chartContainer.appendChild(lowerThresholdLabel);
  }

  // Update candle data for chart periodically every 5s
  let klinesUpdateInterval = null;
  async function updateChartData() {
    if(!selectedSymbol) return;
    try {
      const klines = await fetchKlines(selectedSymbol, '1m', 100);
      candleSeries.setData(klines);
      // Get last candle close as base price to draw thresholds
      const lastCandle = klines[klines.length-1];
      if(lastCandle){
        drawThresholds(lastCandle.close);
        checkAlerts(lastCandle.close);
      }
    } catch(e) {
      showError(`Error actualizando gráfico: ${e.message}`);
    }
  }

  // Show error in popup for 4s
  function showError(msg) {
    if (popupContainer.style.display === 'block') return; // Don't override popups
    popupContainer.style.display = 'block';
    popupContainer.innerHTML = `<h3>Error</h3><p>${msg}</p>`;
    setTimeout(() => {
      popupContainer.style.display = 'none';
      popupContainer.innerHTML = '';
    }, 4000);
  }

  // Show alert popup
  function showAlert(msg) {
    alert(msg);
  }

  // Check thresholds alert and notify if crossed
  let lastAlertTriggered = null;
  function checkAlerts(currentPrice) {
    if(!alertsRealTimeEnabled) return;
    if (!currentPrice) return;
    const upLimit = currentPrice * (1 + thresholds.max / 100);
    const lowLimit = currentPrice * (1 + thresholds.min / 100);

    // Only alert if price goes beyond thresholds relative to base price
    // But we need base price when selected: We'll use last basePrice stored
    // Instead, we alert if currentPrice crosses the threshold lines relative to base price stored

    // We'll store basePrice on last candle close on updateChartData()
    // We'll track last alert time to avoid spamming

    // For simplicity alert if currentPrice >= upLimit or <= lowLimit

    // Avoid flooding alerts, alert max once per minute
    const now = Date.now();
    if (lastAlertTriggered && now - lastAlertTriggered < 60000) return;

    if(currentPrice >= upLimit){
      showAlert(`Alerta: Precio ${selectedSymbol} superó umbral máximo (${thresholds.max}%)`);
      lastAlertTriggered = now;
    } else if(currentPrice <= lowLimit){
      showAlert(`Alerta: Precio ${selectedSymbol} bajó del umbral mínimo (${thresholds.min}%)`);
      lastAlertTriggered = now;
    }
  }

  // Open popup with crypto list
  function openCryptoPopup() {
    popupContainer.style.display = 'block';
    popupContainer.innerHTML = `
      <span class="close-btn" id="popup-close">&times;</span>
      <h3>Selecciona una criptomoneda (solo 1)</h3>
      <ul id="crypto-list"></ul>
      <button id="close-no-select" class="btn mt-3 w-full">Cerrar sin seleccionar</button>
      <p class="mt-2 text-xs text-gray-400">* Sólo puede seleccionarse una moneda.</p>
    `;
    const closeBtn = document.getElementById('popup-close');
    const closeNoSelectBtn = document.getElementById('close-no-select');
    const listElem = document.getElementById('crypto-list');

    // Fill crypto list with popularCoins info and prices
    fetchCoinsInfo().then(coins => {
      listElem.innerHTML = '';
      coins.forEach(coin => {
        const li = document.createElement('li');
        li.textContent = `${coin.symbol}`;
        const priceSpan = document.createElement('span');
        priceSpan.textContent = coin.lastPrice.toFixed(4);
        priceSpan.style.marginLeft = 'auto';
        const changeSpan = document.createElement('span');
        changeSpan.textContent = (coin.priceChangePercent >= 0 ? '+' : '') + coin.priceChangePercent.toFixed(2) + '%';
        changeSpan.style.color = coin.priceChangePercent >= 0 ? '#22c55e' : '#ef4444'; // green or red
        changeSpan.style.marginLeft = '8px';
        li.appendChild(priceSpan);
        li.appendChild(changeSpan);
        if (coin.symbol === selectedSymbol) li.classList.add('selected');
        li.onclick = () => {
          if (coin.symbol === selectedSymbol) return;
          selectedSymbol = coin.symbol;
          localStorage.setItem(LOCALSTORAGE_KEYS.symbol, selectedSymbol);
          closePopup();
          refreshAfterSelection();
        };
        listElem.appendChild(li);
      });
    }).catch(() => {
      showError('Error cargando lista de criptomonedas');
    });

    closeBtn.onclick = closeNoSelectBtn.onclick = () => {
      closePopup();
    };
  }

  // Open popup to select thresholds
  function openThresholdsPopup() {
    popupContainer.style.display = 'block';
    popupContainer.innerHTML = `
      <span class="close-btn" id="popup-close">&times;</span>
      <h3>Configurar umbrales (%)</h3>
      <label for="min-threshold">Umbral mínimo (porcentaje, negativo)</label>
      <input id="min-threshold" type="number" step="0.1" value="${thresholds.min}" />
      <label for="max-threshold" class="mt-2">Umbral máximo (porcentaje, positivo)</label>
      <input id="max-threshold" type="number" step="0.1" value="${thresholds.max}" />
      <div class="mt-4 flex justify-between">
        <button id="save-thresholds" class="btn">Guardar</button>
        <button id="close-thresholds" class="btn">Cerrar sin guardar</button>
      </div>
    `;
    const closeBtn = document.getElementById('popup-close');
    const btnSave = document.getElementById('save-thresholds');
    const btnClose = document.getElementById('close-thresholds');

    closeBtn.onclick = btnClose.onclick = () => {
      closePopup();
    };

    btnSave.onclick = () => {
      const minVal = parseFloat(document.getElementById('min-threshold').value);
      const maxVal = parseFloat(document.getElementById('max-threshold').value);
      if (isNaN(minVal) || isNaN(maxVal) || minVal >= 0 || maxVal <= 0) {
        alert('Por favor ingresa valores válidos. Mínimo debe ser negativo y máximo positivo.');
        return;
      }
      thresholds.min = minVal;
      thresholds.max = maxVal;
      localStorage.setItem(LOCALSTORAGE_KEYS.thresholds, JSON.stringify(thresholds));
      closePopup();
      // Redibujar umbrales en gráfico
      updateChartData();
    };
  }

  // Open popup for alerts config
  function openAlertsPopup() {
    popupContainer.style.display = 'block';
    popupContainer.innerHTML = `
      <span class="close-btn" id="popup-close">&times;</span>
      <h3>Configurar alertas</h3>
      <label>Alertas en tiempo real</label>
      <select id="alerts-realtime-select" class="w-full bg-[#222] text-white p-1 rounded">
        <option value="yes" ${alertsRealTimeEnabled ? 'selected' : ''}>Sí</option>
        <option value="no" ${!alertsRealTimeEnabled ? 'selected' : ''}>No</option>
      </select>
      <label class="mt-4">Alertas por email</label>
      <p class="text-xs text-gray-400">(No implementado aún)</p>
      <div class="mt-4 flex justify-end">
        <button id="close-alerts" class="btn">Cerrar</button>
      </div>
    `;
    const closeBtn = document.getElementById('popup-close');
    const closeBtn2 = document.getElementById('close-alerts');
    const alertsSelect = document.getElementById('alerts-realtime-select');

    closeBtn.onclick = closeBtn2.onclick = () => {
      closePopup();
    };

    alertsSelect.onchange = () => {
      alertsRealTimeEnabled = alertsSelect.value === 'yes';
      localStorage.setItem(LOCALSTORAGE_KEYS.alertsRealTime, alertsRealTimeEnabled);
    };
  }

  // Close popup
  function closePopup() {
    popupContainer.style.display = 'none';
    popupContainer.innerHTML = '';
  }

  // Refresh chart and coin list after selection
  function refreshAfterSelection() {
    initCoinList();
    initChart();
    updateChartData();
    if(klinesUpdateInterval) clearInterval(klinesUpdateInterval);
    klinesUpdateInterval = setInterval(updateChartData, 5000);
  }

  // Initialize buttons event listeners
  function initButtons() {
    btnCrypto.onclick = openCryptoPopup;
    btnThresholds.onclick = openThresholdsPopup;
    btnAlerts.onclick = openAlertsPopup;
  }

  // Init all
  async function init() {
    initButtons();
    await initCoinList();
    initChart();
    await updateChartData();
    klinesUpdateInterval = setInterval(updateChartData, 5000);
  }

  // Run init on page load
  window.onload = () => {
    init();
  };
</script>

</body>
</html>
